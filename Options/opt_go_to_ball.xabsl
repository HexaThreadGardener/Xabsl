/* opt_go_to_ball: From arbitrary position, suppose the ball is seen, go to ball, and rotate to face the goal.
 *
 * Clarification of terms:
 * For sake of generalization, the terms "left", "right" and "goal" should be interpreted as follows in this option:
 *  - "goal": the position the robot wants to kick the ball to (not necessarily the actual goal)
 * Now let's denote robot as R, ball as B, and "goal" as G.
 *  - "left": the front of the robot and \vec{BG} are on the same side of line RB (see case 2 of opt_go_to_ball.png)
 *  - "right": the front of the robot and \vec{BG} are on different sides of line RB (see case 1 of opt_go_to_ball.png)
 *
 * The strategy:
 *  - When "left": rotate --> walk an "S" shape --> rotate
 *  - When "right": rotate --> walk an arc --> rotate
 * Note: the whole process is Markov.
 *
 * Reads: 
 * - is_within_tol              (whether the ball bearing is small enough for the robot to walk to it without in-place rotating)
 * - is_left                    (whether the relative position is "left")
 * - is_near_enough             (whether the robot is near enough to the ball to kick it)
 *
 * Writes:
 * - headMode
 *
 * Behaves:
 * - behavior_nothing
 * - TODO
 */

option opt_go_to_ball
{
    initial state check_before_walk {                           // 0
        decision {
            if (state_time < T_WAIT_BEFORE_WALK) {
                stay;
            }
            else {
                if (is_near_enough) {
                    // when the ball is already near (e.g. kickoff), use rotation mode to adjust toward the "goal" directly
                    // goto rotate_after_walk;
                    stay;        // TODO: fix this state!
                }
                else if (is_within_tol) {
                    if (is_left) {
                        goto during_left_walk;
                    }
                    else {
                        goto during_right_walk;
                    }
                }
                else {
                    goto rotate_before_walk;
                }
            }
        }
        action {
            headMode = HorizontalTrack;
            behavior_nothing();     // wait until the flags are ready
        }
    }

    // TODO: use the new "rotate" behavior

    state rotate_before_walk {                              // 1
        decision {
            if (is_within_tol) {
                if (is_left) {
                    goto during_left_walk;
                }
                else {
                    goto during_right_walk;
                }
            }
            else {
                stay;
            }
        }
        action {
            //headMode = FarMid;
            headMode = HorizontalTrack;
            behavior_rotate_before_walk();
        }
    }

    state during_left_walk {                            // 2
        decision {
            if (is_near_enough) {
                goto prepare_approach_ball;
            }
            else {
                if (is_left) {
                    stay;
                }
                else {
                    goto during_right_walk;
                }
            }
        }
        action {
            headMode = BothTrack;
            behavior_during_left_walk();
        }
    }

    state during_right_walk {                       // 3
        decision {
            if (is_near_enough) {
                goto prepare_approach_ball;
            }
            else {
                if (!is_left) {
                    stay;
                }
                else {
                    goto during_left_walk;
                }
            }
        }
        action {
            headMode = BothTrack;
            behavior_during_right_walk();
        }
    }

    state prepare_approach_ball {               // 4
        decision {
            if (is_robot_moving) {
                stay;
            }
            else {
                goto go_to_ball_done;
                //goto wait_before_approach_ball;
            }
        }
        action {
            headMode = BothTrack;
            behavior_stop_walk();
        }
    }

    state wait_before_approach_ball {           // 5
        decision {
            if (state_time < 2000) {
                stay;
            } else {
                goto approach_ball;
            }
        }
        action {
            //headMode = FarMid;
            behavior_nothing();
        }
    }

    state approach_ball {               // 6
        decision {
            if (state_time < 2000) {
                stay;
            }
            else {
            if (is_robot_moving)
            {stay;}
            else {
                goto go_to_ball_done;
                }
            }
        }
        action {
            //headMode = FarMid;
            behavior_approach_ball();
        }
    }

    target state go_to_ball_done {          // 7
        decision {
            stay;
        }
        action {
            behavior_nothing();
        }
    }
}
